
// @version=6

indicator('POND MA Pro', 'POND MA PRO', overlay = true)

///////////////////////////////////////////////////////////////////////////////
// Constant variable Declarations

const string t1 = 'MA 1'
const string t2 = 'MA 2'
const string t3 = 'MA 3'
const string t4 = 'MA 4'
const string t5 = 'MA 5'
const string t6 = 'MA 6'
const string t7 = 'MA 7'
const string t8 = 'MA 8'
const string t9 = 'MA 9'

const string SMA = 'SMA'
const string EMA = 'EMA'
const string RMA = 'RMA'
const string WMA = 'WMA'
const string HMA = 'HMA'
const string LMA = 'LSMA'

const string SMA_t = 'Simple Moving Average'
const string EMA_t = 'Exponential Moving Average'
const string RMA_t = 'Relative Moving Average'
const string WMA_t = 'Weighted Moving Average'
const string HMA_t = 'Hull Moving Average'
const string LMA_t = 'Least Squares Moving Average'

const string srcTip    = 'Choose price data source from dropdown list.\nDefault is closing prices.'
const string maOnTip   = 'Tick checkbox to plot moving averages\nselected below.'
const string crosOnTip = 'Tick checkbox to plot crossover prices for\nmoving average pairs selected below.'
const string maTipA    = 'Tick left checkbox to select moving average.\nDefine length with numerical input box.\nChoose type from dropdown list.\n'
const string maTipB    = '\nDefine color with color input box.'
const string maTip     =  maTipA + '\n'+SMA+' : '+SMA_t+'\n'+EMA+' : '+EMA_t+'\n'+RMA+' : '+RMA_t+'\n'+WMA+' : '+WMA_t+ '\n'+HMA+' : '+HMA_t+'\n'+LMA+' : '+LMA_t+'\n'+maTipB
const string fillTip   = 'Tick left checkbox to select fill between\nmoving average pairs chosen from dropdown lists.\nTick right checkbox to select single color.\nDefault is a gradiant between MA line colors'
const string crossTip  = 'Tick left checkbox to select crossover pair of\nmoving averages chosen from dropdown lists.\nTick right checkbox to select color.\nDefault is the midcolor between MA line colors'
const string fillOnTip = 'Tick checkbox to plot fill colors between\nmoving average pairs selected below.'
const string maWidTip  = 'Define MA line plot width [1-4]\nDefault is 2'
const string crsWidTip = 'Define cross price line plot width [1-4]\nDefault is 1'
const string noCrosTip = 'Choose a crossover pair or,\nturn off the crossover info panel\nfrom the settings.'
const string pnlMaTipA = 'Column showing\nselected crossover pairs of moving averages.'
const string pnlMaTipB = 'Column showing\nselected crossover pairs of moving averages,\nand their prices'
const string pnlCrTipA = 'Column showing the crossover price\nto cross chosen pairs of moving averages\non the current bar.'
const string pnlCrTipB = 'Column showing the crossover price\nand crossover condition required\nto cross chosen pairs of moving averages\non the current bar.'
const string panelOnTip = 'Tick checkbox to display moving average crossover info panel.'
const string titleOnTip = 'Tick checkbox to show info panel title.'
const string xMaPrOnTip = 'Tick checkbox to show moving average prices.'
const string xCondTip   = 'Tick checkbox to show crossover conditions.'
const string xNumTip    = 'Tick checkbox to show crossover pair numbers.'
const string decimalTip = 'Define decimal places to be shown in panel displayed prices with numerical input box. [0-16]\nDefault is 2'
const string panColTip  = 'Define colors for the background, frame and main header text with the color selection boxes.'

const string bufferZeroes = "0000000000"

const color ma1_color  = color.rgb(135, 206, 250) // Light Sky Blue
const color ma2_color  = color.rgb(173, 216, 230) // Light Blue
const color ma3_color  = color.rgb(176, 224, 230) // Powder Blue
const color ma4_color  = color.rgb(100, 149, 237) // Cornflower Blue
const color ma5_color  = color.rgb(70, 130, 180)  // Steel Blue
const color ma6_color  = color.rgb(0, 191, 255)   // Deep Sky Blue
const color ma7_color  = color.rgb(30, 144, 255)  // Dodger Blue
const color ma8_color  = color.rgb(65, 105, 225)  // Royal Blue
const color ma9_color  = color.rgb(25, 25, 112)   // Midnight Blue

const color x1_color   = color.rgb ( 255, 146, 146 )
const color x2_color   = color.rgb ( 131, 199, 255 )
const color x3_color   = color.rgb ( 153, 153, 153 )
const color x4_color   = color.rgb ( 255, 242, 125 )
const color x5_color   = color.rgb ( 134, 71, 145 ) 

const color f1_color   = color.rgb ( 255, 127, 0 )
const color f2_color   = color.rgb ( 255, 255, 0 )
const color f3_color   = color.rgb ( 0, 255, 0 ) ,
const color f4_color   = color.rgb ( 0, 255, 255 )
const color f5_color   = color.rgb ( 0, 0, 255) , 

const color pan_bg_col = color.rgb ( 0, 0, 0 )
const color pan_fr_col = color.rgb ( 126, 126, 126 )
const color pan_tx_col = color.rgb ( 255, 255, 255 )


///////////////////////////////////////////////////////////////////////////////
// Inputs

i_src       = input.source ( close, 'Price Source.', srcTip,                                        inline = '1',       group = 'Main Properties' )

i_mas_on    = input.bool ( true, 'Show : Moving Average Lines.', maOnTip,                           inline = '1',       group = 'Moving Average Properties' )
i_ma1_on    = input.bool ( false,   t1,                                                             inline = 'MA 1',    group = 'Moving Average Properties' )
i_ma2_on    = input.bool ( false,   t2,                                                             inline = 'MA 2',    group = 'Moving Average Properties' )
i_ma3_on    = input.bool ( false,   t3,                                                             inline = 'MA 3',    group = 'Moving Average Properties' )
i_ma4_on    = input.bool ( true,    t4,                                                             inline = 'MA 4',    group = 'Moving Average Properties' )
i_ma5_on    = input.bool ( true,    t5,                                                             inline = 'MA 5',    group = 'Moving Average Properties' )
i_ma6_on    = input.bool ( true,    t6,                                                             inline = 'MA 6',    group = 'Moving Average Properties' )
i_ma7_on    = input.bool ( false,   t7,                                                             inline = 'MA 7',    group = 'Moving Average Properties' )
i_ma8_on    = input.bool ( true,    t8,                                                             inline = 'MA 8',    group = 'Moving Average Properties' )
i_ma9_on    = input.bool ( false,   t9,                                                             inline = 'MA 9',    group = 'Moving Average Properties' )

i_ma1_len   = input.int ( 10,   '', minval = 1,                                                     inline = 'MA 1',    group = 'Moving Average Properties' )
i_ma2_len   = input.int ( 50,   '', minval = 1,                                                     inline = 'MA 2',    group = 'Moving Average Properties' )
i_ma3_len   = input.int ( 200,  '', minval = 1,                                                     inline = 'MA 3',    group = 'Moving Average Properties' )
i_ma4_len   = input.int ( 5,    '', minval = 1,                                                     inline = 'MA 4',    group = 'Moving Average Properties' )
i_ma5_len   = input.int ( 21,   '', minval = 1,                                                     inline = 'MA 5',    group = 'Moving Average Properties' )
i_ma6_len   = input.int ( 55,   '', minval = 1,                                                     inline = 'MA 6',    group = 'Moving Average Properties' )
i_ma7_len   = input.int ( 89,   '', minval = 1,                                                     inline = 'MA 7',    group = 'Moving Average Properties' )
i_ma8_len   = input.int ( 200,  '', minval = 1,                                                     inline = 'MA 8',    group = 'Moving Average Properties' )
i_ma9_len   = input.int ( 377,  '', minval = 1,                                                     inline = 'MA 9',    group = 'Moving Average Properties' )

i_ma1_typ   = input.string ( SMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 1',    group = 'Moving Average Properties' )
i_ma2_typ   = input.string ( SMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 2',    group = 'Moving Average Properties' )
i_ma3_typ   = input.string ( SMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 3',    group = 'Moving Average Properties' )
i_ma4_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 4',    group = 'Moving Average Properties' )
i_ma5_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 5',    group = 'Moving Average Properties' )
i_ma6_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 6',    group = 'Moving Average Properties' )
i_ma7_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 7',    group = 'Moving Average Properties' )
i_ma8_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 8',    group = 'Moving Average Properties' )
i_ma9_typ   = input.string ( EMA, '', [ SMA, EMA, RMA, WMA, HMA, LMA ],                             inline = 'MA 9',    group = 'Moving Average Properties' )

i_ma1_col   = input.color ( ma1_color, '', maTip,                                                   inline = 'MA 1',    group = 'Moving Average Properties' )
i_ma2_col   = input.color ( ma2_color, '', maTip,                                                   inline = 'MA 2',    group = 'Moving Average Properties' )
i_ma3_col   = input.color ( ma3_color, '', maTip,                                                   inline = 'MA 3',    group = 'Moving Average Properties' )
i_ma4_col   = input.color ( ma4_color, '', maTip,                                                   inline = 'MA 4',    group = 'Moving Average Properties' )
i_ma5_col   = input.color ( ma5_color, '', maTip,                                                   inline = 'MA 5',    group = 'Moving Average Properties' )
i_ma6_col   = input.color ( ma6_color, '', maTip,                                                   inline = 'MA 6',    group = 'Moving Average Properties' )
i_ma7_col   = input.color ( ma7_color, '', maTip,                                                   inline = 'MA 7',    group = 'Moving Average Properties' )
i_ma8_col   = input.color ( ma8_color, '', maTip,                                                   inline = 'MA 8',    group = 'Moving Average Properties' )
i_ma9_col   = input.color ( ma9_color, '', maTip,                                                   inline = 'MA 9',    group = 'Moving Average Properties' )

i_ma_line_w = input.int ( 2,  'Line width', 1, 4, tooltip = maWidTip,                               inline = '10',      group = 'Moving Average Properties' )

i_x_ln_on   = input.bool ( false, 'Plot : Crossover Lines.', crosOnTip,                             inline = '1',       group = 'Moving Average Crossover Pairs' )
i_x1_on     = input.bool ( false,  'Pair 1',                                                        inline = 'Pair 1',  group = 'Moving Average Crossover Pairs' )
i_x2_on     = input.bool ( false,  'Pair 2',                                                        inline = 'Pair 2',  group = 'Moving Average Crossover Pairs' )
i_x3_on     = input.bool ( true,   'Pair 3',                                                        inline = 'Pair 3',  group = 'Moving Average Crossover Pairs' )
i_x4_on     = input.bool ( true,   'Pair 4',                                                        inline = 'Pair 4',  group = 'Moving Average Crossover Pairs' )
i_x5_on     = input.bool ( true,   'Pair 5',                                                        inline = 'Pair 5',  group = 'Moving Average Crossover Pairs' )

i_x1_t1     = input.string ( t1, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 1',  group = 'Moving Average Crossover Pairs' )
i_x1_t2     = input.string ( t2, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 1',  group = 'Moving Average Crossover Pairs' )
i_x2_t1     = input.string ( t2, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 2',  group = 'Moving Average Crossover Pairs' )
i_x2_t2     = input.string ( t3, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 2',  group = 'Moving Average Crossover Pairs' )
i_x3_t1     = input.string ( t4, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 3',  group = 'Moving Average Crossover Pairs' )
i_x3_t2     = input.string ( t5, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 3',  group = 'Moving Average Crossover Pairs' )
i_x4_t1     = input.string ( t5, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 4',  group = 'Moving Average Crossover Pairs' )
i_x4_t2     = input.string ( t6, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 4',  group = 'Moving Average Crossover Pairs' )
i_x5_t1     = input.string ( t6, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 5',  group = 'Moving Average Crossover Pairs' )
i_x5_t2     = input.string ( t8, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 5',  group = 'Moving Average Crossover Pairs' )

i_x1_col    = input.color ( x1_color, '',                                                           inline = 'Pair 1',  group = 'Moving Average Crossover Pairs' )
i_x2_col    = input.color ( x2_color, '',                                                           inline = 'Pair 2',  group = 'Moving Average Crossover Pairs' )
i_x3_col    = input.color ( x3_color, '',                                                           inline = 'Pair 3',  group = 'Moving Average Crossover Pairs' )
i_x4_col    = input.color ( x4_color, '',                                                           inline = 'Pair 4',  group = 'Moving Average Crossover Pairs' )
i_x5_col    = input.color ( x5_color, '',                                                           inline = 'Pair 5',  group = 'Moving Average Crossover Pairs' )

i_x1_c_on   = input.bool ( false, '', crossTip,                                                     inline = 'Pair 1',  group = 'Moving Average Crossover Pairs' )
i_x2_c_on   = input.bool ( false, '', crossTip,                                                     inline = 'Pair 2',  group = 'Moving Average Crossover Pairs' )
i_x3_c_on   = input.bool ( false, '', crossTip,                                                     inline = 'Pair 3',  group = 'Moving Average Crossover Pairs' )
i_x4_c_on   = input.bool ( false, '', crossTip,                                                     inline = 'Pair 4',  group = 'Moving Average Crossover Pairs' )
i_x5_c_on   = input.bool ( false, '', crossTip,                                                     inline = 'Pair 5',  group = 'Moving Average Crossover Pairs' )

i_x_line_w  = input.int ( 1,  'Line width.', 1, 4, tooltip = crsWidTip,                             inline = '6',       group = 'Moving Average Crossover Pairs' )

i_fill_on   = input.bool ( false, 'Plot : Moving Average Fills.', fillOnTip,                        inline = '1',       group = 'Moving Average Fill Pairs' )
i_f1_on     = input.bool ( false, 'Pair 1',                                                         inline = 'Pair 1',  group = 'Moving Average Fill Pairs' )
i_f2_on     = input.bool ( false, 'Pair 2',                                                         inline = 'Pair 2',  group = 'Moving Average Fill Pairs' )
i_f3_on     = input.bool ( false, 'Pair 3',                                                         inline = 'Pair 3',  group = 'Moving Average Fill Pairs' )
i_f4_on     = input.bool ( false, 'Pair 4',                                                         inline = 'Pair 4',  group = 'Moving Average Fill Pairs' )
i_f5_on     = input.bool ( false, 'Pair 5',                                                         inline = 'Pair 5',  group = 'Moving Average Fill Pairs' )

i_f1_t1     = input.string ( t4, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 1',  group = 'Moving Average Fill Pairs' )
i_f1_t2     = input.string ( t5, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 1',  group = 'Moving Average Fill Pairs' )
i_f2_t1     = input.string ( t5, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 2',  group = 'Moving Average Fill Pairs' )
i_f2_t2     = input.string ( t6, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 2',  group = 'Moving Average Fill Pairs' )
i_f3_t1     = input.string ( t6, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 3',  group = 'Moving Average Fill Pairs' )
i_f3_t2     = input.string ( t7, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 3',  group = 'Moving Average Fill Pairs' )
i_f4_t1     = input.string ( t7, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 4',  group = 'Moving Average Fill Pairs' )
i_f4_t2     = input.string ( t8, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 4',  group = 'Moving Average Fill Pairs' )
i_f5_t1     = input.string ( t8, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 5',  group = 'Moving Average Fill Pairs' )
i_f5_t2     = input.string ( t9, '', [ t1, t2, t3, t4, t5, t6, t7, t8, t9 ],                        inline = 'Pair 5',  group = 'Moving Average Fill Pairs' )

i_f1_col    = input.color ( f1_color, '',                                                           inline = 'Pair 1',  group = 'Moving Average Fill Pairs' )
i_f2_col    = input.color ( f2_color, '',                                                           inline = 'Pair 2',  group = 'Moving Average Fill Pairs' )
i_f3_col    = input.color ( f3_color, '',                                                           inline = 'Pair 3',  group = 'Moving Average Fill Pairs' )
i_f4_col    = input.color ( f4_color, '',                                                           inline = 'Pair 4',  group = 'Moving Average Fill Pairs' )
i_f5_col    = input.color ( f5_color, '',                                                           inline = 'Pair 5',  group = 'Moving Average Fill Pairs' )

i_f1_c_on   = input.bool ( false, '', fillTip,                                                      inline = 'Pair 1',  group = 'Moving Average Fill Pairs' )
i_f2_c_on   = input.bool ( false, '', fillTip,                                                      inline = 'Pair 2',  group = 'Moving Average Fill Pairs' )
i_f3_c_on   = input.bool ( false, '', fillTip,                                                      inline = 'Pair 3',  group = 'Moving Average Fill Pairs' )
i_f4_c_on   = input.bool ( false, '', fillTip,                                                      inline = 'Pair 4',  group = 'Moving Average Fill Pairs' )
i_f5_c_on   = input.bool ( false, '', fillTip,                                                      inline = 'Pair 5',  group = 'Moving Average Fill Pairs' )

i_panel_on  = input.bool   ( true,  'Show : Info Panel.',               panelOnTip,                 inline = '1',       group = 'Crossover Info Panel Properties' )
i_title_on  = input.bool   ( true,  'Show : Info Panel Title.',         titleOnTip,                 inline = '2',       group = 'Crossover Info Panel Properties' )
i_x_price   = input.bool   ( false, 'Show : Crossover MA Prices.',      xMaPrOnTip,                 inline = '3',       group = 'Crossover Info Panel Properties' )
i_x_cond    = input.bool   ( true,  'Show : Crossover Condition.',      xCondTip,                   inline = '4',       group = 'Crossover Info Panel Properties' )
i_x_num     = input.bool   ( true,  'Show : Crossover Pair Numbers.',   xNumTip,                    inline = '5',       group = 'Crossover Info Panel Properties' )
i_places    = input.int    ( 2,     'Decimal Places Shown.', 0, 16, tooltip = decimalTip,           inline = '6',       group = 'Crossover Info Panel Properties' )
i_pan_bg_c  = input.color  ( pan_bg_col, 'Background',                                              inline = '7',       group = 'Crossover Info Panel Properties' )
i_pan_fr_c  = input.color  ( pan_fr_col, 'Frame',                                                   inline = '7',       group = 'Crossover Info Panel Properties' )
i_pan_tx_c  = input.color  ( pan_tx_col, 'Main Text', panColTip,                                    inline = '7',       group = 'Crossover Info Panel Properties' )


///////////////////////////////////////////////////////////////////////////////
// Define ma object type

// @type                : A user-defined type containing moving average information.
// @field title         : Text title of moving average.
// @field typ           : Text denoting moving average type.
// @field desc          : Text description of moving average length and type.
// @field len           : Moving average length.
// @field val           : Moving average value.
// @field col           : Moving average color.
// @field alpha         : Moving average alpha.
// @field wmaLen        : Moving average length.
// @field halfLen       : Half MA length.
// @field sqrtLen       : Square root of MA length.
// @field pWma          : Previous WMA of MA length.
// @field pHwma         : Previous WMA of Half MA length.
type ma
    string title = na
    string typ   = na
    string desc  = na
    int    len   = na
    float  val   = na
    color  col   = na
    float alpha  = na
    int  wmaLen  = 2
    int halfLen  = 2
    int sqrtLen  = 2
    float pWma   = na
    float pHwma  = na


///////////////////////////////////////////////////////////////////////////////
// Function Declarations

// @function            : Calculates crossover price between 2 HMA's.
// @param price         : Price source.
// @param hmaLen1       : HMA length.
// @param hmaHalfLen1   : HMA half length.
// @param hmaSqrtLen1   : HMA squared root length.
// @param pHmaWma1      : Previous WMA of HMA length.
// @param pHmaHwma1     : Previous WMA of half HMA length.
// @param hmaLen2       : HMA length.
// @param hmaHalfLen2   : HMA half length.
// @param hmaSqrtLen2   : HMA squared root length.
// @param pHmaWma2      : Previous WMA of HMA length.
// @param pHmaHwma2     : Previous WMA of half HMA length..
// @returns             : (float) Crossover price.
hmaHmaCross ( float price, int hmaLen1, int hmaHalfLen1, int hmaSqrtLen1, float pHmaWma1, pHmaHwma1, int hmaLen2, int hmaHalfLen2, int hmaSqrtLen2, float pHmaWma2, pHmaHwma2 ) =>

    p = price

    x = hmaHalfLen1
    z = hmaSqrtLen1
    y = hmaLen1
    a = pHmaHwma1 
    b = pHmaWma1 

    finalPriceA = (((a*((x-1)*x/2))+p*x)*2/(x*(x+1))*2)-(((b*((y-1)*y/2))+p*y)*2/(y*(y+1)))

    c = 0.0
    for i = 1 to z-1
        c := c + finalPriceA[i] * ( z - i )

    l = hmaHalfLen2
    n = hmaSqrtLen2
    m = hmaLen2
    d = pHmaHwma2 
    e = pHmaWma2  

    finalPriceB = (((d*((l-1)*l/2))+p*l)*2/(l*(l+1))*2)-(((e*((m-1)*m/2))+p*m)*2/(m*(m+1)))

    f = 0.0
    for i = 1 to n-1
        f := f + finalPriceB[i] * ( n - i )

    hmaHmaCross = (z*(z+1)*f+z*(z+1)*n*(4*(d*((l-1)*l/2))/(l*(l+1))-2*(e*((m-1)*m/2))/(m*(m+1)))-n*(n+1)*c-n*(n+1)*z*(4*(a*((x-1)*x/2))/(x*(x+1))-2*(b*((y-1)*y/2))/(y*(y+1)))) / (n*(n+1)*z*(4/(x+1)-2/(y+1))-z*(z+1)*n*(4/(l+1)-2/(m+1)))


// @function            : Calculates crossover price between a HMA and a SMA.
// @param price         : Price source.
// @param hmaLen        : HMA length.
// @param hmaHalfLen    : HMA half length.
// @param hmaSqrtLen    : HMA squared root length.
// @param pHmaWma       : Previous WMA of HMA length.
// @param pHmaHwma      : Previous WMA of half HMA length.
// @param smaLen        : SMA length.
// @param pMa2Psum      : Previous price sum of SMA length.
// @returns             : (float) Crossover price.
hmaSmaCross ( float price, int hmaLen, int hmaHalfLen, int hmaSqrtLen, float pHmaWma, pHmaHwma, int smaLen, float pMa2Psum ) =>

    x = hmaHalfLen
    z = hmaSqrtLen
    y = hmaLen
    a = pHmaHwma 
    b = pHmaWma

    finalPriceA = (-(x+1)*(b*(y-1)+2*price)+2*(y+1)*(a*(x-1)+2*price))/((x+1)*(y+1))

    c = 0.0
    for i = 1 to z-1
        c := c + finalPriceA[i] * ( z - i )

    s = pMa2Psum 
    k = smaLen

    hmaSmaCrossPrice = (s*z*(z+1)-2*k*c-2*k*z*(4*(a*((x-1)*x/2))/(x*(x+1))-2*(b*((y-1)*y/2))/(y*(y+1))))/(2*k*z*(4/(x+1)-2/(y+1))-z*(z+1))


// @function            : Calculates crossover price between a HMA and an exponential MA.
// @param price         : Price source.
// @param hmaLen        : HMA length.
// @param hmaHalfLen    : HMA half length.
// @param hmaSqrtLen    : HMA squared root length.
// @param pHmaWma       : Previous WMA of HMA length.
// @param pHmaHwma      : Previous WMA of half HMA length.
// @param expAlpha      : Exponential alpha.
// @param pExpMa        : Previous exponential MA.
// @returns             : (float) Crossover price.
hmaExpCross ( float price, int hmaLen, int hmaHalfLen, int hmaSqrtLen, float pHmaWma, pHmaHwma, float expAlpha, float pExpMa ) =>

    x = hmaHalfLen
    z = hmaSqrtLen
    y = hmaLen
    a = pHmaHwma 
    b = pHmaWma

    finalPriceA = (-(x+1)*(b*(y-1)+2*price)+2*(y+1)*(a*(x-1)+2*price))/((x+1)*(y+1))

    c = 0.0
    for i = 1 to z-1
        c := c + finalPriceA[i] * ( z - i )

    j = expAlpha
    v = pExpMa

    hmaExpCrossPrice = ((z*(z+1)/2)*(1-j)*v-c-z*(4*(a*((x-1)*x/2))/(x*(x+1))-2*(b*((y-1)*y/2))/(y*(y+1))))/(z*(4/(x+1)-2/(y+1))-(z*(z+1)/2)*j)


// @function            : Calculates crossover price between a HMA and a WMA.
// @param price         : Price source.
// @param hmaLen        : HMA length.
// @param hmaHalfLen    : HMA half length.
// @param hmaSqrtLen    : HMA squared root length.
// @param pHmaWma       : Previous WMA of HMA length.
// @param pHmaHwma      : Previous WMA of half HMA length.
// @param wmaLen        : WMA length.
// @param pWma          : Previous WMA.
// @returns             : (float) Crossover price.
hmaWmaCross ( float price, int hmaLen, int hmaHalfLen, int hmaSqrtLen, float pHmaWma, pHmaHwma, int wmaLen, float pWma  ) =>

    x = hmaHalfLen
    z = hmaSqrtLen
    y = hmaLen
    a = pHmaHwma
    b = pHmaWma

    finalPriceA = (-(x+1)*(b*(y-1)+2*price)+2*(y+1)*(a*(x-1)+2*price))/((x+1)*(y+1))

    c = 0.0
    for i = 1 to z-1
        c := c + finalPriceA[i] * ( z - i )

    v = wmaLen
    k = pWma

    hmaWmaCross = (z*(z+1)*(k*((v-1)*v/2))-v*(v+1)*c-v*(v+1)*z*(4*(a*((x-1)*x/2))/(x*(x+1))-2*(b*((y-1)*y/2))/(y*(y+1))))/(v*z*((v+1)*(4/(x+1)-2/(y+1))-(z+1)))


// @function            : Calculates crossover price between a HMA and a LSMA.
// @param price         : Price source.
// @param hmaLen        : HMA length.
// @param hmaHalfLen    : HMA half length.
// @param hmaSqrtLen    : HMA squared root length.
// @param pHmaWma       : Previous WMA of HMA length.
// @param pHmaHwma      : Previous WMA of half HMA length.
// @param lsmaLen       : LSMA length.
// @param pLsmaPsum     : Previous price sum of LSMA length.
// @param lsmaPwma      : Previous WMA of LSMA length.
// @returns             : (float) Crossover price.
hmaLsmaCross ( float price, int hmaLen, int hmaHalfLen, int hmaSqrtLen, float pHmaWma, pHmaHwma, int lsmaLen, float pLsmaPsum, float lsmaPwma ) =>

    x = hmaHalfLen
    z = hmaSqrtLen
    y = hmaLen
    a = pHmaHwma 
    b = pHmaWma  

    finalPriceA = (-(x+1)*(b*(y-1)+2*price)+2*(y+1)*(a*(x-1)+2*price))/((x+1)*(y+1))

    c = 0.0
    for i = 1 to z-1
        c := c + finalPriceA[i] * ( z - i )

    n = lsmaLen
    d = pLsmaPsum 
    k = lsmaPwma

    out = (2/(z*(z+1))*(c+z*(2*a*(x-1)/(x+1)-b*(y-1)/(y+1)))-d/n+((n-1)/2)*(n*d-(n-1)*(k*n+d)/2)/(((n-1)*n*(2*n-1)/6)-n*(n-1)*(n-1)/2+((n-1)*(n-1)*(n-1))/4+((n-1)*(n-1))/4))/(1/n+((n-1)*(n-1)/4)/(((n-1)*n*(2*n-1)/6)-n*(n-1)*(n-1)/2+((n-1)*(n-1)*(n-1))/4+((n-1)*(n-1))/4)-2/(z+1)*(4/(x+1)-2/(y+1)))


// @function            : Calculates crossover price between a LSMA and a SMA.
// @param lsmaLen       : LSMA length.
// @param lsmaAlpha     : LSMA alpha.
// @param lsmaPwma      : Previous WMA of LSMA length.
// @param pLsmaPsum     : Previous price sum of LSMA length.
// @param smaLen        : SMA length.
// @param pSmaPsum      : Previous price sum of SMA length.
// @returns             : (float) Crossover price.
lsmaSmaCross ( int lsmaLen, float lsmaPwma, float pLsmaPsum, int smaLen, float pSmaPsum ) =>

    int   n = lsmaLen
    float k = lsmaPwma
    float d = pLsmaPsum

    int   x = smaLen
    float s = pSmaPsum

    out = (n*x*((n-1)/2)*(n*d - ((n-1)*(k*n+d)/2)) - (x*d-n*s)*(n*(n-1)*(n+1)/12))/((x-n)*(n*(n-1)*(n+1)/12) + n*x*(((n-1)*(n-1))/4))


// @function            : Calculates crossover price between a LSMA and an Exponential Moving Average (EMA or RMA).
// @param lsmaLen       : LSMA length.
// @param lsmaPwma      : Previous WMA of LSMA len.
// @param pLsmaPsum     : Previous price sum of LSMA len.
// @param expMaAlpha    : Exponential ma alpha.
// @param pExpMaVal     : Previous exponential ma value.
// @returns             : (float) Crossover price.
lsmaExpCross ( int lsmaLen, float lsmaPwma, float pLsmaPsum, float expMaAlpha, float pExpMaVal ) =>

    int   n = lsmaLen
    float x = lsmaPwma
    float d = pLsmaPsum

    float a = expMaAlpha
    float s = pExpMaVal

    lsmaExpCross = ((1-a)*s-(d/n)+(((n-1)/2)*((n*d)-((n-1)*(x*n+d)/2))/(((n-1)*n*(n+1))/12)))/((1/n)+(3*(n-1)/(n*(n+1)))-a)


// @function            : Calculates crossover price between a LSMA and a WMA.
// @param lsmaLen       : LSMA length.
// @param lsmaPwma      : Previous WMA of LSMA length.
// @param pLsmaPsum     : Previous price sum of LSMA length.
// @param wmaLen        : WMA length.
// @param pWma          : Previous WMA.
// @returns             : (float) Crossover price.
lsmaWmaCross ( int lsmaLen, float lsmaPwma, float pLsmaPsum, int wmaLen, float pWma ) =>

    n = lsmaLen
    d = pLsmaPsum
    x = lsmaPwma

    y = wmaLen
    k = pWma

    lsmaWmaCross = (2*n*((((n-1)*n*(2*n-1)/6)-2*((n-1)/2)*((n-1)*n/2)+((n-1)/2)*((n-1)/2)*(n-1))+((n-1)/2)*((n-1)/2))*(k*((y-1)*y/2))-y*(y+1)*(d*((((n-1)*n*(2*n-1)/6)-2*((n-1)/2)*((n-1)*n/2)+((n-1)/2)*((n-1)/2)*(n-1))+((n-1)/2)*((n-1)/2))-n*((n-1)/2)*(n*d-x*((n-1)*n/2)-((n-1)/2)*d)))/(y*((y+1)*((((n-1)*n*(2*n-1)/6)-2*((n-1)/2)*((n-1)*n/2)+((n-1)/2)*((n-1)/2)*(n-1))+((n-1)/2)*((n-1)/2)*(1+n))-2*n*((((n-1)*n*(2*n-1)/6)-2*((n-1)/2)*((n-1)*n/2)+((n-1)/2)*((n-1)/2)*(n-1))+((n-1)/2)*((n-1)/2))))


// @function            : Calculates crossover price between 2 LSMA's.
// @param lsmaLen1      : LSMA 1 length.
// @param lsmaPwma1     : Previous WMA of LSMA 1 length.
// @param pLsmaPsum1    : Previous price sum of LSMA 1 length.
// @param lsmaLen2      : LSMA 2 length.
// @param lsmaPwma2     : Previous WMA of LSMA 2 length.
// @param pLsmaPsum2    : Previous price sum of LSMA 2 length.
// @returns             : (float) Crossover price.
lsmaLsmaCross ( int lsmaLen1, float lsmaPwma1, float pLsmaPsum1, int lsmaLen2, float lsmaPwma2, float pLsmaPsum2 ) =>

    n = lsmaLen1
    d = pLsmaPsum1
    x = lsmaPwma1

    N = lsmaLen2
    D = pLsmaPsum2
    y = lsmaPwma2

    out = (D*n*(N+1)*(n+1)-N*d*(N+1)*(n+1)+3*N*(N+1)*(2*d*n-(d+n*x)*(n-1))+3*n*(n+1)*(-2*D*N+(D+N*y)*(N-1)))/(3*N*(N+1)*(n-1)+N*(N+1)*(n+1)+3*n*(1-N)*(n+1)-n*(N+1)*(n+1))


// @function            : Calculates crossover price for 2 ma objects.
// @param price         : Current price.
// @param ma1           : Crossover ma object 1.
// @param ma2           : Crossover ma object 2.
// @returns             : (float) Crossover price.
f_ma_cross_price ( float price, ma ma1, ma ma2 ) =>

    float pMa1Psum = math.sum ( price[1], ma1.len - 1 )
    float pMa2Psum = math.sum ( price[1], ma2.len - 1 )

    float val1 = ma1.val
    float val2 = ma2.val

    float pMaVal1 = val1[1]
    float pMaVal2 = val2[1]

    string testString = ma1.typ+ma2.typ
    float crossPrice = switch testString

        'SMASMA'     => ( pMa1Psum * ma2.len - pMa2Psum * ma1.len ) / ( ma1.len - ma2.len )
        'EMAEMA'     => ((( 1 - ma2.alpha ) * pMaVal2 ) - (( 1 - ma1.alpha ) * pMaVal1 )) / ( ma1.alpha - ma2.alpha )
        'SMAEMA'     => ( ma1.len * ( 1 - ma2.alpha ) * pMaVal2 - pMa1Psum ) / ( 1 - ma1.len * ma2.alpha )
        'EMASMA'     => ( ma2.len * ( 1 - ma1.alpha ) * pMaVal1 - pMa2Psum ) / ( 1 - ma2.len * ma1.alpha )
        'SMARMA'     => ( ma1.len * ( 1 - ma2.alpha ) * pMaVal2 - pMa1Psum ) / ( 1 - ma1.len * ma2.alpha )
        'RMASMA'     => ( ma2.len * ( 1 - ma1.alpha ) * pMaVal1 - pMa2Psum ) / ( 1 - ma2.len * ma1.alpha )
        'RMARMA'     => (( 1 - ma2.alpha ) * pMaVal2 - ( 1 - ma1.alpha ) * pMaVal1 ) / ( ma1.alpha - ma2.alpha )
        'RMAEMA'     => ((( 1 - ma1.alpha ) * pMaVal1 ) - (( 1 - ma2.alpha ) * pMaVal2) ) / ( ma2.alpha - ma1.alpha )
        'EMARMA'     => ((( 1 - ma2.alpha ) * pMaVal2 ) - (( 1 - ma1.alpha ) * pMaVal1) ) / ( ma1.alpha - ma2.alpha )
        'WMAWMA'     => (( ma2.pWma * (( ma2.len - 1 ) * ma2.len / 2 )) * ma1.len * ( ma1.len + 1 ) - ( ma1.pWma * (( ma1.len - 1 ) * ma1.len / 2 )) * ma2.len * ( ma2.len + 1 )) / ( ma1.len * ma2.len * ( ma2.len - ma1.len ))
        'SMAWMA'     => ( 2 * ma1.len * ( ma2.pWma * (( ma2.len - 1 ) * ma2.len / 2 )) - pMa1Psum * ma2.len * ( ma2.len + 1 )) / ( ma2.len * (( ma2.len + 1 ) - 2 * ma1.len ))
        'WMASMA'     => ( 2 * ma2.len * ( ma1.pWma * (( ma1.len - 1 ) * ma1.len / 2 )) - pMa2Psum * ma1.len * ( ma1.len + 1 )) / ( ma1.len * (( ma1.len + 1 ) - 2 * ma2.len ))
        'EMAWMA'     => ( 2 * ( ma2.pWma * (( ma2.len - 1 ) * ma2.len / 2 )) - ( 1 - ma1.alpha ) * pMaVal1 * ma2.len * ( ma2.len + 1 )) / ( ma1.alpha * ma2.len * ( ma2.len + 1 ) - 2 * ma2.len )
        'WMAEMA'     => ( 2 * ( ma1.pWma * (( ma1.len - 1 ) * ma1.len / 2 )) - ( 1 - ma2.alpha ) * pMaVal2 * ma1.len * ( ma1.len + 1 )) / ( ma2.alpha * ma1.len * ( ma1.len + 1 ) - 2 * ma1.len )
        'RMAWMA'     => ( 2 * ( ma2.pWma * (( ma2.len - 1 ) * ma2.len / 2 )) - ( 1 - ma1.alpha ) * pMaVal1 * ma2.len * ( ma2.len + 1 )) / ( ma1.alpha * ma2.len * ( ma2.len + 1 ) - 2 * ma2.len )
        'WMARMA'     => ( 2 * ( ma1.pWma * (( ma1.len - 1 ) * ma1.len / 2 )) - ( 1 - ma2.alpha ) * pMaVal2 * ma1.len * ( ma1.len + 1 )) / ( ma2.alpha * ma1.len * ( ma1.len + 1 ) - 2 * ma1.len )
        'WMAHMA'     => hmaWmaCross ( price, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma, ma1.len, ma1.pWma )
        'HMAWMA'     => hmaWmaCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.len, ma2.pWma )
        'SMAHMA'     => hmaSmaCross ( price, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma, ma1.len, pMa1Psum )
        'HMASMA'     => hmaSmaCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.len, pMa2Psum )
        'EMAHMA'     => hmaExpCross ( price, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma, ma1.alpha, pMaVal1 )
        'HMAEMA'     => hmaExpCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.alpha, pMaVal2 )
        'RMAHMA'     => hmaExpCross ( price, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma, ma1.alpha, pMaVal1 )
        'HMARMA'     => hmaExpCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.alpha, pMaVal2 )
        'HMAHMA'     => hmaHmaCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma )
        'LSMAHMA'   => hmaLsmaCross ( price, ma2.len, ma2.halfLen, ma2.sqrtLen, ma2.pWma, ma2.pHwma, ma1.len, pMa1Psum, ma1.pWma )
        'HMALSMA'   => hmaLsmaCross ( price, ma1.len, ma1.halfLen, ma1.sqrtLen, ma1.pWma, ma1.pHwma, ma2.len, pMa2Psum, ma2.pWma )
        'SMALSMA'   => lsmaSmaCross ( ma2.len, ma2.pWma, pMa2Psum, ma1.len, pMa1Psum )
        'LSMASMA'   => lsmaSmaCross ( ma1.len, ma1.pWma, pMa1Psum, ma2.len, pMa2Psum )
        'LSMAEMA'   => lsmaExpCross ( ma1.len, ma1.pWma, pMa1Psum, ma2.alpha, pMaVal2 )
        'EMALSMA'   => lsmaExpCross ( ma2.len, ma2.pWma, pMa2Psum, ma1.alpha, pMaVal1 )
        'LSMARMA'   => lsmaExpCross ( ma1.len, ma1.pWma, pMa1Psum, ma2.alpha, pMaVal2 )
        'RMALSMA'   => lsmaExpCross ( ma2.len, ma2.pWma, pMa2Psum, ma1.alpha, pMaVal1 )
        'LSMAWMA'   => lsmaWmaCross ( ma1.len, ma1.pWma, pMa1Psum, ma2.len, ma2.pWma )
        'WMALSMA'   => lsmaWmaCross ( ma2.len, ma2.pWma, pMa2Psum, ma1.len, ma1.pWma )
        'LSMALSMA' => lsmaLsmaCross ( ma1.len, ma1.pWma, pMa1Psum, ma2.len, ma2.pWma, pMa2Psum )
        => 0

    crossPrice > 0 ? crossPrice : 0.0


// @function            : Selects one of up to nine moving average (ma) objects based on an indexing title string.
// @param maTitle       : indexing title string identifier.
// @param ma1 - ma9     : ma objects.
// @returns             : (ma) Selected ma object.
f_indexer ( string maTitle, ma ma1, ma ma2, ma ma3, ma ma4, ma ma5, ma ma6, ma ma7, ma ma8, ma ma9 ) =>
    switch maTitle
        t1 => ma1
        t2 => ma2
        t3 => ma3
        t4 => ma4
        t5 => ma5
        t6 => ma6
        t7 => ma7
        t8 => ma8
        => ma9


// @function            : Selects one of 6 const text strings from input ma type.
// @param MA            : ma object.
// @returns             : (ma) Descriptive text string.
f_ma_txt ( ma MA ) =>
    switch MA.typ
        SMA => SMA_t
        EMA => EMA_t
        RMA => RMA_t
        WMA => WMA_t
        HMA => HMA_t
        => LMA_t


// @function            : Adds decimal and zeroes to input truncated number string.
// @param decimalTxt    : Truncated number as string.
// @param places        : Number of decimal places to be shown.
// @returns             : (float) Returns number as a string with correct decimal places shown.
f_padZeros ( string decimalTxt, int places ) =>

    if not str.contains ( decimalTxt, '.' )
        decimalTxt + "." + str.substring ( bufferZeroes, 0, places )
    else
        int decPos = str.pos ( decimalTxt, "." )
        int currentPlaces = str.length ( decimalTxt ) - decPos - 1
        int extraZeros = places - currentPlaces
        extraZeros > 0 ? decimalTxt + str.substring ( bufferZeroes, 0, extraZeros ) : decimalTxt


// @function            : Formats input value for display.
// @param value         : Input value.
// @param places        : Number of decimal places to be shown.
// @returns             : (float) Returns number as a string with a decimal and correct decimal places shown.
f_formatNumber ( float value, int places ) =>
    if places <= 0
        str.tostring(int(value))
    else
        float multiplier = math.pow(10, places)
        float truncated = int(value * multiplier) / multiplier
        f_padZeros(str.tostring(truncated), places)


// @function            : Constructs conditional text string from ma object.
// @param MA            : ma object.
// @param pricesOn      : conditional boolean to put price in output string.
// @param decPlaces     : Number of places to be shown after the decimal.
// @returns             : (string) Moving average text.
f_ma_text ( ma MA, bool pricesOn, int decPlaces ) =>
    str.tostring ( MA.len ) + ' ' + MA.typ + ( pricesOn ? ' : ' + f_formatNumber ( MA.val, decPlaces ) : na )


// @function            : Constructs conditional text string from price and crossPrice.
// @param price         : Current price.
// @param crossPrice    : Crossover price.
// @returns             : (string) Crossover condition text.
f_cross_text ( float price, float crossPrice ) =>
    if i_x_cond 
        crossPrice > 0 and price > crossPrice ? 'Close Below : ' + f_formatNumber ( crossPrice, i_places ) : crossPrice > 0 ? 'Close Above : ' + f_formatNumber ( crossPrice, i_places ) : 'Impossible'
    else
        crossPrice > 0 and price > crossPrice ? f_formatNumber ( crossPrice, i_places ) : crossPrice > 0 ? f_formatNumber ( crossPrice, i_places ) : ' Impossible '


// @function            : Constructs conditional text string from price and crossPrice.
// @param price         : Current price.
// @param crossPrice    : Crossover price.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @returns             : (string) Crossover condition text.
f_cross_cond_tip ( float price, float crossPrice, ma ma1, ma ma2 ) =>
    crossPrice > 0 and price > crossPrice ? 'To cross the\n' + ma1.desc + '\nbelow the\n'+ ma2.desc + '\nClose below : ' + f_formatNumber ( crossPrice, i_places ) :
     crossPrice > 0 ? 'To cross the\n' + ma2.desc + '\nabove the\n' + ma1.desc + '\nClose Above : ' + f_formatNumber ( crossPrice, i_places ) :
     'It is impossible to cross the\n' + ma2.desc + '\nabove the\n' + ma1.desc + '\non this bar close'


// @function            : Constructs text string from pairNum and 2 ma object descriptions.
// @param pairNum       : Crossover number.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @returns             : (string) Crossover pair text for tooltip.
f_cross_pair_tip ( int pairNum, ma ma1, ma ma2 ) =>
    'Crossover pair ' + str.tostring ( pairNum ) + '\n' + ma1.desc + '\n' + ma2.desc


// @function            : Constructs descriptive text string from ma object.
// @param pairNum       : Crossover pair number.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @returns             : (string) descriptive text string.
f_ma_desc ( ma MA ) =>
    MA.title + ' : ' + str.tostring ( MA.len ) + ' ' + f_ma_txt ( MA )


// @function            : Chooses a midpoint color between 2 ma object colors or the input userColor depending on input conditional logic userColorOn.
// @param userColorOn   : Logic condition for user color.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @param userColor     : user selected color.
// @returns             : (color) Color for crossover plot.
f_cross_color ( bool userColorOn, ma ma1, ma ma2, color userColor ) =>
    not userColorOn ? color.from_gradient ( 500, 0, 1000, ma1.col, ma2.col ) : userColor


// @function            : Conditionally chooses an ma object selected from input ma object pairs prices.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @returns             : (ma) moving average object.
f_hiLoMa ( ma ma1, ma ma2 ) =>
    ma1.val > ma2.val ? ma1 : ma2


// @function            : Chooses an ma object conditionally selected from input ma object pair prices.
// @param ma1           : ma object 1.
// @param ma2           : ma object 2.
// @returns             : (ma) moving average object.
f_loHiMa ( ma ma1, ma ma2 ) =>
    ma1.val > ma2.val ? ma2 : ma1


///////////////////////////////////////////////////////////////////////////////
// Initialize ma objects

var ma ma1_obj = ma.new ( t1, i_ma1_typ, na, i_ma1_len, na, i_ma1_col )
var ma ma2_obj = ma.new ( t2, i_ma2_typ, na, i_ma2_len, na, i_ma2_col )
var ma ma3_obj = ma.new ( t3, i_ma3_typ, na, i_ma3_len, na, i_ma3_col )
var ma ma4_obj = ma.new ( t4, i_ma4_typ, na, i_ma4_len, na, i_ma4_col )
var ma ma5_obj = ma.new ( t5, i_ma5_typ, na, i_ma5_len, na, i_ma5_col )
var ma ma6_obj = ma.new ( t6, i_ma6_typ, na, i_ma6_len, na, i_ma6_col )
var ma ma7_obj = ma.new ( t7, i_ma7_typ, na, i_ma7_len, na, i_ma7_col )
var ma ma8_obj = ma.new ( t8, i_ma8_typ, na, i_ma8_len, na, i_ma8_col )
var ma ma9_obj = ma.new ( t9, i_ma9_typ, na, i_ma9_len, na, i_ma9_col )

var ma x1_ma1  = f_indexer ( i_x1_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x1_ma2  = f_indexer ( i_x1_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x2_ma1  = f_indexer ( i_x2_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x2_ma2  = f_indexer ( i_x2_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x3_ma1  = f_indexer ( i_x3_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x3_ma2  = f_indexer ( i_x3_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x4_ma1  = f_indexer ( i_x4_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x4_ma2  = f_indexer ( i_x4_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x5_ma1  = f_indexer ( i_x5_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj )
var ma x5_ma2  = f_indexer ( i_x5_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) 

var ma f1_ma1  = i_fill_on and i_f1_on ? f_indexer ( i_f1_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f1_ma2  = i_fill_on and i_f1_on ? f_indexer ( i_f1_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f2_ma1  = i_fill_on and i_f2_on ? f_indexer ( i_f2_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f2_ma2  = i_fill_on and i_f2_on ? f_indexer ( i_f2_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f3_ma1  = i_fill_on and i_f3_on ? f_indexer ( i_f3_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f3_ma2  = i_fill_on and i_f3_on ? f_indexer ( i_f3_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f4_ma1  = i_fill_on and i_f4_on ? f_indexer ( i_f4_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f4_ma2  = i_fill_on and i_f4_on ? f_indexer ( i_f4_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f5_ma1  = i_fill_on and i_f5_on ? f_indexer ( i_f5_t1, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na
var ma f5_ma2  = i_fill_on and i_f5_on ? f_indexer ( i_f5_t2, ma1_obj, ma2_obj, ma3_obj, ma4_obj, ma5_obj, ma6_obj, ma7_obj, ma8_obj, ma9_obj ) : na


///////////////////////////////////////////////////////////////////////////////
// Initialize fill colors

var color f1_col1 = i_fill_on and i_f1_on ? not i_f1_c_on ? f1_ma1.col : i_f1_col : na
var color f1_col2 = i_fill_on and i_f1_on ? not i_f1_c_on ? f1_ma2.col : i_f1_col : na
var color f2_col1 = i_fill_on and i_f2_on ? not i_f2_c_on ? f2_ma1.col : i_f2_col : na
var color f2_col2 = i_fill_on and i_f2_on ? not i_f2_c_on ? f2_ma2.col : i_f2_col : na
var color f3_col1 = i_fill_on and i_f3_on ? not i_f3_c_on ? f3_ma1.col : i_f3_col : na
var color f3_col2 = i_fill_on and i_f3_on ? not i_f3_c_on ? f3_ma2.col : i_f3_col : na
var color f4_col1 = i_fill_on and i_f4_on ? not i_f4_c_on ? f4_ma1.col : i_f4_col : na
var color f4_col2 = i_fill_on and i_f4_on ? not i_f4_c_on ? f4_ma2.col : i_f4_col : na
var color f5_col1 = i_fill_on and i_f5_on ? not i_f5_c_on ? f5_ma1.col : i_f5_col : na
var color f5_col2 = i_fill_on and i_f5_on ? not i_f5_c_on ? f5_ma2.col : i_f5_col : na

// Crossover colors

var color cross_col1 = i_x1_on and i_x_ln_on ? f_cross_color ( i_x1_c_on, x1_ma1, x1_ma2, i_x1_col ) : na
var color cross_col2 = i_x2_on and i_x_ln_on ? f_cross_color ( i_x2_c_on, x2_ma1, x2_ma2, i_x2_col ) : na
var color cross_col3 = i_x3_on and i_x_ln_on ? f_cross_color ( i_x3_c_on, x3_ma1, x3_ma2, i_x3_col ) : na
var color cross_col4 = i_x4_on and i_x_ln_on ? f_cross_color ( i_x4_c_on, x4_ma1, x4_ma2, i_x4_col ) : na
var color cross_col5 = i_x5_on and i_x_ln_on ? f_cross_color ( i_x5_c_on, x5_ma1, x5_ma2, i_x5_col ) : na


///////////////////////////////////////////////////////////////////////////////
// Initialize conditional tooltips

var string pnlMaTip = i_x_price ? pnlMaTipB : pnlMaTipA
var string pnlCrTip = i_x_cond  ? pnlCrTipB : pnlCrTipA


///////////////////////////////////////////////////////////////////////////////
// Set object constants

if barstate.isfirst

    ma1_obj.alpha   := i_ma1_typ == EMA ? 2 / ( i_ma1_len + 1 ) : i_ma1_typ == RMA ? 1 / i_ma1_len : na
    ma2_obj.alpha   := i_ma2_typ == EMA ? 2 / ( i_ma2_len + 1 ) : i_ma2_typ == RMA ? 1 / i_ma2_len : na
    ma3_obj.alpha   := i_ma3_typ == EMA ? 2 / ( i_ma3_len + 1 ) : i_ma3_typ == RMA ? 1 / i_ma3_len : na
    ma4_obj.alpha   := i_ma4_typ == EMA ? 2 / ( i_ma4_len + 1 ) : i_ma4_typ == RMA ? 1 / i_ma4_len : na
    ma5_obj.alpha   := i_ma5_typ == EMA ? 2 / ( i_ma5_len + 1 ) : i_ma5_typ == RMA ? 1 / i_ma5_len : na
    ma6_obj.alpha   := i_ma6_typ == EMA ? 2 / ( i_ma6_len + 1 ) : i_ma6_typ == RMA ? 1 / i_ma6_len : na
    ma7_obj.alpha   := i_ma7_typ == EMA ? 2 / ( i_ma7_len + 1 ) : i_ma7_typ == RMA ? 1 / i_ma7_len : na
    ma8_obj.alpha   := i_ma8_typ == EMA ? 2 / ( i_ma8_len + 1 ) : i_ma8_typ == RMA ? 1 / i_ma8_len : na
    ma9_obj.alpha   := i_ma9_typ == EMA ? 2 / ( i_ma9_len + 1 ) : i_ma9_typ == RMA ? 1 / i_ma9_len : na

    ma1_obj.halfLen := math.floor ( ma1_obj.len / 2 )
    ma2_obj.halfLen := math.floor ( ma2_obj.len / 2 )
    ma3_obj.halfLen := math.floor ( ma3_obj.len / 2 )
    ma4_obj.halfLen := math.floor ( ma4_obj.len / 2 )
    ma5_obj.halfLen := math.floor ( ma5_obj.len / 2 )
    ma6_obj.halfLen := math.floor ( ma6_obj.len / 2 )
    ma7_obj.halfLen := math.floor ( ma7_obj.len / 2 )
    ma8_obj.halfLen := math.floor ( ma8_obj.len / 2 )
    ma9_obj.halfLen := math.floor ( ma9_obj.len / 2 )

    ma1_obj.sqrtLen := math.floor ( math.sqrt ( ma1_obj.len ))
    ma2_obj.sqrtLen := math.floor ( math.sqrt ( ma2_obj.len ))
    ma3_obj.sqrtLen := math.floor ( math.sqrt ( ma3_obj.len ))
    ma4_obj.sqrtLen := math.floor ( math.sqrt ( ma4_obj.len ))
    ma5_obj.sqrtLen := math.floor ( math.sqrt ( ma5_obj.len ))
    ma6_obj.sqrtLen := math.floor ( math.sqrt ( ma6_obj.len ))
    ma7_obj.sqrtLen := math.floor ( math.sqrt ( ma7_obj.len ))
    ma8_obj.sqrtLen := math.floor ( math.sqrt ( ma8_obj.len ))
    ma9_obj.sqrtLen := math.floor ( math.sqrt ( ma9_obj.len ))

    ma1_obj.desc    := f_ma_desc ( ma1_obj )
    ma2_obj.desc    := f_ma_desc ( ma2_obj )
    ma3_obj.desc    := f_ma_desc ( ma3_obj )
    ma4_obj.desc    := f_ma_desc ( ma4_obj )
    ma5_obj.desc    := f_ma_desc ( ma5_obj )
    ma6_obj.desc    := f_ma_desc ( ma6_obj )
    ma7_obj.desc    := f_ma_desc ( ma7_obj )
    ma8_obj.desc    := f_ma_desc ( ma8_obj )
    ma9_obj.desc    := f_ma_desc ( ma9_obj )

    // selectively set cross price wmaLen and halfLen variables

    x1_ma1.wmaLen   := i_x1_on and ( x1_ma1.typ == HMA or x1_ma1.typ == WMA or x1_ma1.typ == LMA ) ? x1_ma1.len - 1 : 2
    x1_ma2.wmaLen   := i_x1_on and ( x1_ma2.typ == HMA or x1_ma2.typ == WMA or x1_ma2.typ == LMA ) ? x1_ma2.len - 1 : 2
    x2_ma1.wmaLen   := i_x2_on and ( x2_ma1.typ == HMA or x2_ma1.typ == WMA or x2_ma1.typ == LMA ) ? x2_ma1.len - 1 : 2
    x2_ma2.wmaLen   := i_x2_on and ( x2_ma2.typ == HMA or x2_ma2.typ == WMA or x2_ma2.typ == LMA ) ? x2_ma2.len - 1 : 2
    x3_ma1.wmaLen   := i_x3_on and ( x3_ma1.typ == HMA or x3_ma1.typ == WMA or x3_ma1.typ == LMA ) ? x3_ma1.len - 1 : 2
    x3_ma2.wmaLen   := i_x3_on and ( x3_ma2.typ == HMA or x3_ma2.typ == WMA or x3_ma2.typ == LMA ) ? x3_ma2.len - 1 : 2
    x4_ma1.wmaLen   := i_x4_on and ( x4_ma1.typ == HMA or x4_ma1.typ == WMA or x4_ma1.typ == LMA ) ? x4_ma1.len - 1 : 2
    x4_ma2.wmaLen   := i_x4_on and ( x4_ma2.typ == HMA or x4_ma2.typ == WMA or x4_ma2.typ == LMA ) ? x4_ma2.len - 1 : 2
    x5_ma1.wmaLen   := i_x5_on and ( x5_ma1.typ == HMA or x5_ma1.typ == WMA or x5_ma1.typ == LMA ) ? x5_ma1.len - 1 : 2
    x5_ma2.wmaLen   := i_x5_on and ( x5_ma2.typ == HMA or x5_ma2.typ == WMA or x5_ma2.typ == LMA ) ? x5_ma2.len - 1 : 2

    x1_ma1.halfLen  := i_x1_on and x1_ma1.typ == HMA ? x1_ma1.halfLen : 2
    x1_ma2.halfLen  := i_x1_on and x1_ma2.typ == HMA ? x1_ma2.halfLen : 2
    x2_ma1.halfLen  := i_x2_on and x2_ma1.typ == HMA ? x2_ma1.halfLen : 2
    x2_ma2.halfLen  := i_x2_on and x2_ma2.typ == HMA ? x2_ma2.halfLen : 2
    x3_ma1.halfLen  := i_x3_on and x3_ma1.typ == HMA ? x3_ma1.halfLen : 2
    x3_ma2.halfLen  := i_x3_on and x3_ma2.typ == HMA ? x3_ma2.halfLen : 2
    x4_ma1.halfLen  := i_x4_on and x4_ma1.typ == HMA ? x4_ma1.halfLen : 2
    x4_ma2.halfLen  := i_x4_on and x4_ma2.typ == HMA ? x4_ma2.halfLen : 2
    x5_ma1.halfLen  := i_x5_on and x5_ma1.typ == HMA ? x5_ma1.halfLen : 2
    x5_ma2.halfLen  := i_x5_on and x5_ma2.typ == HMA ? x5_ma2.halfLen : 2


///////////////////////////////////////////////////////////////////////////////
// Calculate

float pSrc = i_src[1]

// moving average price values

ma1_obj.val := i_ma1_typ==SMA ? ta.sma(i_src,i_ma1_len) : i_ma1_typ==EMA ? ta.ema(i_src,i_ma1_len) : i_ma1_typ==RMA ? ta.rma(i_src,i_ma1_len) : i_ma1_typ==WMA ? ta.wma(i_src,i_ma1_len) : i_ma1_typ==HMA ? ta.hma(i_src,i_ma1_len) : ta.linreg(i_src,i_ma1_len,0)
ma2_obj.val := i_ma2_typ==SMA ? ta.sma(i_src,i_ma2_len) : i_ma2_typ==EMA ? ta.ema(i_src,i_ma2_len) : i_ma2_typ==RMA ? ta.rma(i_src,i_ma2_len) : i_ma2_typ==WMA ? ta.wma(i_src,i_ma2_len) : i_ma2_typ==HMA ? ta.hma(i_src,i_ma2_len) : ta.linreg(i_src,i_ma2_len,0)
ma3_obj.val := i_ma3_typ==SMA ? ta.sma(i_src,i_ma3_len) : i_ma3_typ==EMA ? ta.ema(i_src,i_ma3_len) : i_ma3_typ==RMA ? ta.rma(i_src,i_ma3_len) : i_ma3_typ==WMA ? ta.wma(i_src,i_ma3_len) : i_ma3_typ==HMA ? ta.hma(i_src,i_ma3_len) : ta.linreg(i_src,i_ma3_len,0)
ma4_obj.val := i_ma4_typ==SMA ? ta.sma(i_src,i_ma4_len) : i_ma4_typ==EMA ? ta.ema(i_src,i_ma4_len) : i_ma4_typ==RMA ? ta.rma(i_src,i_ma4_len) : i_ma4_typ==WMA ? ta.wma(i_src,i_ma4_len) : i_ma4_typ==HMA ? ta.hma(i_src,i_ma4_len) : ta.linreg(i_src,i_ma4_len,0)
ma5_obj.val := i_ma5_typ==SMA ? ta.sma(i_src,i_ma5_len) : i_ma5_typ==EMA ? ta.ema(i_src,i_ma5_len) : i_ma5_typ==RMA ? ta.rma(i_src,i_ma5_len) : i_ma5_typ==WMA ? ta.wma(i_src,i_ma5_len) : i_ma5_typ==HMA ? ta.hma(i_src,i_ma5_len) : ta.linreg(i_src,i_ma5_len,0)  
ma6_obj.val := i_ma6_typ==SMA ? ta.sma(i_src,i_ma6_len) : i_ma6_typ==EMA ? ta.ema(i_src,i_ma6_len) : i_ma6_typ==RMA ? ta.rma(i_src,i_ma6_len) : i_ma6_typ==WMA ? ta.wma(i_src,i_ma6_len) : i_ma6_typ==HMA ? ta.hma(i_src,i_ma6_len) : ta.linreg(i_src,i_ma6_len,0)
ma7_obj.val := i_ma7_typ==SMA ? ta.sma(i_src,i_ma7_len) : i_ma7_typ==EMA ? ta.ema(i_src,i_ma7_len) : i_ma7_typ==RMA ? ta.rma(i_src,i_ma7_len) : i_ma7_typ==WMA ? ta.wma(i_src,i_ma7_len) : i_ma7_typ==HMA ? ta.hma(i_src,i_ma7_len) : ta.linreg(i_src,i_ma7_len,0)
ma8_obj.val := i_ma8_typ==SMA ? ta.sma(i_src,i_ma8_len) : i_ma8_typ==EMA ? ta.ema(i_src,i_ma8_len) : i_ma8_typ==RMA ? ta.rma(i_src,i_ma8_len) : i_ma8_typ==WMA ? ta.wma(i_src,i_ma8_len) : i_ma8_typ==HMA ? ta.hma(i_src,i_ma8_len) : ta.linreg(i_src,i_ma8_len,0)
ma9_obj.val := i_ma9_typ==SMA ? ta.sma(i_src,i_ma9_len) : i_ma9_typ==EMA ? ta.ema(i_src,i_ma9_len) : i_ma9_typ==RMA ? ta.rma(i_src,i_ma9_len) : i_ma9_typ==WMA ? ta.wma(i_src,i_ma9_len) : i_ma9_typ==HMA ? ta.hma(i_src,i_ma9_len) : ta.linreg(i_src,i_ma9_len,0)

// previous wma values ( for crossover calculation )

ma1_obj.pWma  := ( i_ma1_typ == WMA or i_ma1_typ == HMA or i_ma1_typ == LMA ) ? ta.wma ( pSrc, ma1_obj.wmaLen ) : na
ma2_obj.pWma  := ( i_ma2_typ == WMA or i_ma2_typ == HMA or i_ma2_typ == LMA ) ? ta.wma ( pSrc, ma2_obj.wmaLen ) : na
ma3_obj.pWma  := ( i_ma3_typ == WMA or i_ma3_typ == HMA or i_ma3_typ == LMA ) ? ta.wma ( pSrc, ma3_obj.wmaLen ) : na
ma4_obj.pWma  := ( i_ma4_typ == WMA or i_ma4_typ == HMA or i_ma4_typ == LMA ) ? ta.wma ( pSrc, ma4_obj.wmaLen ) : na
ma5_obj.pWma  := ( i_ma5_typ == WMA or i_ma5_typ == HMA or i_ma5_typ == LMA ) ? ta.wma ( pSrc, ma5_obj.wmaLen ) : na
ma6_obj.pWma  := ( i_ma6_typ == WMA or i_ma6_typ == HMA or i_ma6_typ == LMA ) ? ta.wma ( pSrc, ma6_obj.wmaLen ) : na
ma7_obj.pWma  := ( i_ma7_typ == WMA or i_ma7_typ == HMA or i_ma7_typ == LMA ) ? ta.wma ( pSrc, ma7_obj.wmaLen ) : na
ma8_obj.pWma  := ( i_ma8_typ == WMA or i_ma8_typ == HMA or i_ma8_typ == LMA ) ? ta.wma ( pSrc, ma8_obj.wmaLen ) : na
ma9_obj.pWma  := ( i_ma9_typ == WMA or i_ma9_typ == HMA or i_ma9_typ == LMA ) ? ta.wma ( pSrc, ma9_obj.wmaLen ) : na

// previous half len wma values ( for crossover calculation )

ma1_obj.pHwma := i_ma1_typ == HMA ? ta.wma ( pSrc, ma1_obj.halfLen - 1 ) : na
ma2_obj.pHwma := i_ma2_typ == HMA ? ta.wma ( pSrc, ma2_obj.halfLen - 1 ) : na
ma3_obj.pHwma := i_ma3_typ == HMA ? ta.wma ( pSrc, ma3_obj.halfLen - 1 ) : na
ma4_obj.pHwma := i_ma4_typ == HMA ? ta.wma ( pSrc, ma4_obj.halfLen - 1 ) : na
ma5_obj.pHwma := i_ma5_typ == HMA ? ta.wma ( pSrc, ma5_obj.halfLen - 1 ) : na
ma6_obj.pHwma := i_ma6_typ == HMA ? ta.wma ( pSrc, ma6_obj.halfLen - 1 ) : na
ma7_obj.pHwma := i_ma7_typ == HMA ? ta.wma ( pSrc, ma7_obj.halfLen - 1 ) : na
ma8_obj.pHwma := i_ma8_typ == HMA ? ta.wma ( pSrc, ma8_obj.halfLen - 1 ) : na
ma9_obj.pHwma := i_ma9_typ == HMA ? ta.wma ( pSrc, ma9_obj.halfLen - 1 ) : na

// crossover prices

float x1_price = i_x1_on ? f_ma_cross_price ( i_src, x1_ma1, x1_ma2 ) : na
float x2_price = i_x2_on ? f_ma_cross_price ( i_src, x2_ma1, x2_ma2 ) : na
float x3_price = i_x3_on ? f_ma_cross_price ( i_src, x3_ma1, x3_ma2 ) : na
float x4_price = i_x4_on ? f_ma_cross_price ( i_src, x4_ma1, x4_ma2 ) : na
float x5_price = i_x5_on ? f_ma_cross_price ( i_src, x5_ma1, x5_ma2 ) : na


////////////////////////////////////////////////////////////////////////////////
// Display crossover info panel

if i_panel_on
    
    var position = text.align_right
    var table panel = table.new ( position.top_right, 3, 12, i_pan_bg_c, i_pan_fr_c, 2, i_pan_fr_c, 1 )

    if barstate.isfirst

        var int index1 = i_x_num ? 0 : 1
        var int index2 = i_x_num ? 2 : 1

        var string maPair   = i_x_price ? 'MA Pair : Price' : 'MA Pair'
        var string crossTxt = i_x_cond  ? 'Cross Condition : Price' : 'Cross Price'

        if i_title_on
            var string titleTxt = i_x_price or i_x_cond ? "MOVING AVERAGE CROSSOVER LEVELS" : "MOVING AVERAGE\nCROSSOVER LEVELS"
            table.cell ( panel, index1, 0, titleTxt, height = 6, text_color = i_pan_tx_c, text_formatting = text.format_bold )
            table.merge_cells ( panel, index1, 0, 2, 0 )

        table.cell ( panel, index1, 1, maPair,                   text_color = i_pan_tx_c, text_formatting = text.format_bold, tooltip = pnlMaTip )
        table.cell ( panel,      2, 1, crossTxt,                 text_color = i_pan_tx_c, text_formatting = text.format_bold, tooltip = pnlCrTip )

        if i_x_num
            table.merge_cells ( panel, 0, 1, 1, 1 )
            if i_x1_on
                var string tool = f_cross_pair_tip ( 1, x1_ma1, x1_ma2 )
                table.cell ( panel, 0, 2, '1', text_color = i_pan_tx_c, tooltip = tool, text_formatting = text.format_bold )
                table.merge_cells ( panel, 0, 2, 0, 3 )

            if i_x2_on
                var string tool = f_cross_pair_tip ( 2, x2_ma1, x2_ma2 )
                table.cell ( panel, 0, 4, '2', text_color = i_pan_tx_c, tooltip = tool, text_formatting = text.format_bold )
                table.merge_cells ( panel, 0, 4, 0, 5 )

            if i_x3_on
                var string tool = f_cross_pair_tip ( 3, x3_ma1, x3_ma2 )
                table.cell ( panel, 0, 6, '3', text_color = i_pan_tx_c, tooltip = tool, text_formatting = text.format_bold )
                table.merge_cells ( panel, 0, 6, 0, 7 )

            if i_x4_on
                var string tool = f_cross_pair_tip ( 4, x4_ma1, x4_ma2 )
                table.cell ( panel, 0, 8, '4', text_color = i_pan_tx_c, tooltip = tool, text_formatting = text.format_bold )
                table.merge_cells ( panel, 0, 8, 0, 9 )

            if i_x5_on
                var string tool = f_cross_pair_tip ( 5, x5_ma1, x5_ma2 )
                table.cell ( panel, 0, 10, '5', text_color = i_pan_tx_c, tooltip = tool, text_formatting = text.format_bold )
                table.merge_cells ( panel, 0, 10, 0, 11 )

        if i_x1_on
            table.cell ( panel, 2, 2, '', text_color = f_cross_color ( i_x1_c_on, x1_ma1, x1_ma2, i_x1_col ), text_formatting = text.format_bold )
            table.merge_cells ( panel, 2, 2, 2, 3 )

        if i_x2_on
            table.cell ( panel, 2, 4, '', text_color = f_cross_color ( i_x2_c_on, x2_ma1, x2_ma2, i_x2_col ), text_formatting = text.format_bold )
            table.merge_cells ( panel, 2, 4, 2, 5 )

        if i_x3_on
            table.cell ( panel, 2, 6, '', text_color = f_cross_color ( i_x3_c_on, x3_ma1, x3_ma2, i_x3_col ), text_formatting = text.format_bold )
            table.merge_cells ( panel, 2, 6, 2, 7 )

        if i_x4_on
            table.cell ( panel, 2, 8, '', text_color = f_cross_color ( i_x4_c_on, x4_ma1, x4_ma2, i_x4_col ), text_formatting = text.format_bold )
            table.merge_cells ( panel, 2, 8, 2, 9 )

        if i_x5_on
            table.cell ( panel, 2, 10, '', text_color = f_cross_color ( i_x5_c_on, x5_ma1, x5_ma2, i_x5_col ), text_formatting = text.format_bold )
            table.merge_cells ( panel, 2, 10, 2, 11 )

        if ( not i_x1_on and not i_x2_on and not i_x3_on and not i_x4_on and not i_x5_on )
            table.cell ( panel, 0, 2, 'No Crossover pair selected', text_color = i_pan_tx_c, text_halign = text.align_center, text_formatting = text.format_bold, tooltip = noCrosTip )
            table.merge_cells ( panel, 0, 2, 2, 2 )

    if barstate.islast

        if i_x1_on
            var string pairTxt = 'Crossover pair 1\n'
            ma MA1 = f_hiLoMa ( x1_ma1, x1_ma2 )
            ma MA2 = f_loHiMa ( x1_ma1, x1_ma2 )
            string tool = f_cross_cond_tip ( i_src, x1_price, MA1, MA2 )
            table.cell ( panel, 1, 2, f_ma_text ( MA1, i_x_price, i_places ), text_color = MA1.col, text_halign = position, tooltip = pairTxt + MA1.desc, text_formatting = text.format_bold )
            table.cell ( panel, 1, 3, f_ma_text ( MA2, i_x_price, i_places ), text_color = MA2.col, text_halign = position, tooltip = pairTxt + MA2.desc, text_formatting = text.format_bold )
            table.cell_set_text ( panel, 2, 2, f_cross_text ( i_src, x1_price ))
            table.cell_set_tooltip ( panel, 2, 2, tool )

        if i_x2_on
            var string pairTxt = 'Crossover pair 2\n'
            ma MA1 = f_hiLoMa ( x2_ma1, x2_ma2 )
            ma MA2 = f_loHiMa ( x2_ma1, x2_ma2 )
            string tool = f_cross_cond_tip ( i_src, x2_price, MA1, MA2 )
            table.cell ( panel, 1, 4, f_ma_text ( MA1, i_x_price, i_places ), text_color = MA1.col, text_halign = position, tooltip = pairTxt + MA1.desc, text_formatting = text.format_bold )
            table.cell ( panel, 1, 5, f_ma_text ( MA2, i_x_price, i_places ), text_color = MA2.col, text_halign = position, tooltip = pairTxt + MA2.desc, text_formatting = text.format_bold )
            table.cell_set_text ( panel, 2, 4, f_cross_text ( i_src, x2_price ))
            table.cell_set_tooltip ( panel, 2, 4, tool )

        if i_x3_on
            var string pairTxt = 'Crossover pair 3\n'
            ma MA1 = f_hiLoMa ( x3_ma1, x3_ma2 )
            ma MA2 = f_loHiMa ( x3_ma1, x3_ma2 )
            string tool = f_cross_cond_tip ( i_src, x3_price, MA1, MA2 )
            table.cell ( panel, 1, 6, f_ma_text ( MA1, i_x_price, i_places ), text_color = MA1.col, text_halign = position, tooltip = pairTxt + MA1.desc, text_formatting = text.format_bold )
            table.cell ( panel, 1, 7, f_ma_text ( MA2, i_x_price, i_places ), text_color = MA2.col, text_halign = position, tooltip = pairTxt + MA2.desc, text_formatting = text.format_bold )
            table.cell_set_text ( panel, 2, 6, f_cross_text ( i_src, x3_price ))
            table.cell_set_tooltip ( panel, 2, 6, tool )

        if i_x4_on
            var string pairTxt = 'Crossover pair 4\n'
            ma MA1 = f_hiLoMa ( x4_ma1, x4_ma2 )
            ma MA2 = f_loHiMa ( x4_ma1, x4_ma2 )
            string tool = f_cross_cond_tip ( i_src, x4_price, MA1, MA2 )
            table.cell ( panel, 1, 8, f_ma_text ( MA1, i_x_price, i_places ), text_color = MA1.col, text_halign = position, tooltip = pairTxt + MA1.desc, text_formatting = text.format_bold )
            table.cell ( panel, 1, 9, f_ma_text ( MA2, i_x_price, i_places ), text_color = MA2.col, text_halign = position, tooltip = pairTxt + MA2.desc, text_formatting = text.format_bold )
            table.cell_set_text ( panel, 2, 8, f_cross_text ( i_src, x4_price ))
            table.cell_set_tooltip ( panel, 2, 8, tool )

        if i_x5_on
            var string pairTxt = 'Crossover pair 5\n'
            ma MA1 = f_hiLoMa ( x5_ma1, x5_ma2 )
            ma MA2 = f_loHiMa ( x5_ma1, x5_ma2 )
            string tool = f_cross_cond_tip ( i_src, x5_price, MA1, MA2 )
            table.cell ( panel, 1, 10, f_ma_text ( MA1, i_x_price, i_places ), text_color = MA1.col, text_halign = position, tooltip = pairTxt + MA1.desc, text_formatting = text.format_bold )
            table.cell ( panel, 1, 11, f_ma_text ( MA2, i_x_price, i_places ), text_color = MA2.col, text_halign = position, tooltip = pairTxt + MA2.desc, text_formatting = text.format_bold )
            table.cell_set_text ( panel, 2, 10, f_cross_text ( i_src, x5_price ))
            table.cell_set_tooltip ( panel, 2, 10, tool )


///////////////////////////////////////////////////////////////////////////////
// Line plots and fills

// Moving average plots

plot ( i_ma1_on and i_mas_on ? ma1_obj.val : na, 'MA 1', i_ma1_col, i_ma_line_w, editable = false )
plot ( i_ma2_on and i_mas_on ? ma2_obj.val : na, 'MA 2', i_ma2_col, i_ma_line_w, editable = false )
plot ( i_ma3_on and i_mas_on ? ma3_obj.val : na, 'MA 3', i_ma3_col, i_ma_line_w, editable = false )
plot ( i_ma4_on and i_mas_on ? ma4_obj.val : na, 'MA 4', i_ma4_col, i_ma_line_w, editable = false )
plot ( i_ma5_on and i_mas_on ? ma5_obj.val : na, 'MA 5', i_ma5_col, i_ma_line_w, editable = false )
plot ( i_ma6_on and i_mas_on ? ma6_obj.val : na, 'MA 6', i_ma6_col, i_ma_line_w, editable = false )
plot ( i_ma7_on and i_mas_on ? ma7_obj.val : na, 'MA 7', i_ma7_col, i_ma_line_w, editable = false )
plot ( i_ma8_on and i_mas_on ? ma8_obj.val : na, 'MA 8', i_ma8_col, i_ma_line_w, editable = false )
plot ( i_ma9_on and i_mas_on ? ma9_obj.val : na, 'MA 9', i_ma9_col, i_ma_line_w, editable = false )

// Fill line plots

f1_plot1 = plot ( i_f1_on and i_fill_on ? f1_ma1.val : na, 'Fill 1 : Plot 1', na, 1, editable = false, display = display.pane )
f1_plot2 = plot ( i_f1_on and i_fill_on ? f1_ma2.val : na, 'Fill 1 : Plot 2', na, 1, editable = false, display = display.pane )
f2_plot1 = plot ( i_f2_on and i_fill_on ? f2_ma1.val : na, 'Fill 2 : Plot 1', na, 1, editable = false, display = display.pane )
f2_plot2 = plot ( i_f2_on and i_fill_on ? f2_ma2.val : na, 'Fill 2 : Plot 2', na, 1, editable = false, display = display.pane )
f3_plot1 = plot ( i_f3_on and i_fill_on ? f3_ma1.val : na, 'Fill 3 : Plot 1', na, 1, editable = false, display = display.pane )
f3_plot2 = plot ( i_f3_on and i_fill_on ? f3_ma2.val : na, 'Fill 3 : Plot 2', na, 1, editable = false, display = display.pane )
f4_plot1 = plot ( i_f4_on and i_fill_on ? f4_ma1.val : na, 'Fill 4 : Plot 1', na, 1, editable = false, display = display.pane )
f4_plot2 = plot ( i_f4_on and i_fill_on ? f4_ma2.val : na, 'Fill 4 : Plot 2', na, 1, editable = false, display = display.pane )
f5_plot1 = plot ( i_f5_on and i_fill_on ? f5_ma1.val : na, 'Fill 5 : Plot 1', na, 1, editable = false, display = display.pane )
f5_plot2 = plot ( i_f5_on and i_fill_on ? f5_ma2.val : na, 'Fill 5 : Plot 2', na, 1, editable = false, display = display.pane )

// Plotfills

fill ( f1_plot1, f1_plot2, i_f1_on and i_fill_on ? f1_ma1.val : na, i_f1_on and i_fill_on ? f1_ma2.val : na, f1_col1, f1_col2, 'Fill 1', editable = false )
fill ( f2_plot1, f2_plot2, i_f2_on and i_fill_on ? f2_ma1.val : na, i_f2_on and i_fill_on ? f2_ma2.val : na, f2_col1, f2_col2, 'Fill 2', editable = false )
fill ( f3_plot1, f3_plot2, i_f3_on and i_fill_on ? f3_ma1.val : na, i_f3_on and i_fill_on ? f3_ma2.val : na, f3_col1, f3_col2, 'Fill 3', editable = false )
fill ( f4_plot1, f4_plot2, i_f4_on and i_fill_on ? f4_ma1.val : na, i_f4_on and i_fill_on ? f4_ma2.val : na, f4_col1, f4_col2, 'Fill 4', editable = false )
fill ( f5_plot1, f5_plot2, i_f5_on and i_fill_on ? f5_ma1.val : na, i_f5_on and i_fill_on ? f5_ma2.val : na, f5_col1, f5_col2, 'Fill 5', editable = false )

// Crossover line plots

plot ( i_x1_on and i_x_ln_on ? x1_price : na, 'MA Crossover Pair 1', cross_col1, i_x_line_w, editable = false )
plot ( i_x2_on and i_x_ln_on ? x2_price : na, 'MA Crossover Pair 2', cross_col2, i_x_line_w, editable = false )
plot ( i_x3_on and i_x_ln_on ? x3_price : na, 'MA Crossover Pair 3', cross_col3, i_x_line_w, editable = false )
plot ( i_x4_on and i_x_ln_on ? x4_price : na, 'MA Crossover Pair 4', cross_col4, i_x_line_w, editable = false )
plot ( i_x5_on and i_x_ln_on ? x5_price : na, 'MA Crossover Pair 5', cross_col5, i_x_line_w, editable = false )


///////////////////////////////////////////////////////////////////////////////
/// Testing ( I leave this here for noobs to see one 'quick and dirty' testing method I employed to ensure it was performing accurately as I built it, and during the many refactorings )
/// logic = ( x5_ma1.val > x5_ma2.val and i_src < x5_price ) or ( x5_ma1.val < x5_ma2.val and i_src > x5_price )
/// bgcolor ( logic ? color.rgb ( 255, 153, 0, 68 ) : na )

///////////////////////////////////////////////////////////////////////////////
// End
